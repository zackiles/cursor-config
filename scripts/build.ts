#!/usr/bin/env -S deno run -A

/**
 * @module build
 * @description Builds rules.json and rules.md from MDC files in the project.
 *
 * This script processes .mdc files to generate consolidated rulesets and documentation
 * for consumption by the application and users. It performs the following steps:
 *
 * 1. Validates all MDC files using a linter to ensure correctness
 * 2. Processes each .mdc file to extract metadata and content
 * 3. Retrieves Git history for creation and update dates of each rule
 * 4. Simplifies the rule data format for easier consumption
 * 5. Generates a JSON file (rules.json) with processed rule metadata
 * 6. Creates a markdown file (rules.md) with organized documentation in GitHub Flavored Markdown with HTML elements
 * 7. Creates an HTML file (rules.html) from the markdown file using GitHub's Markdown Rendering API
 * 8. Copies other supporting dependencies and documentation files to the output directory
 *
 * @example
 * ```bash
 * deno run -A scripts/build.ts
 * # Or with custom path
 * deno run -A scripts/build.ts .cursor/rules/custom
 * ```
 *
 * @see The processor.ts module for MDC file processing details
 */

import { ensureDir, expandGlob } from '@std/fs'
import { basename, dirname, extname, join } from '@std/path'
import { processMdcFile } from '../src/processor.ts'
import logger from '../src/utils/logger.ts'
import type { RuleFileRaw, RuleFileSimple } from '../src/types.ts'
import { AttachmentType } from '../src/types.ts'

const COMPILE_PATH = Deno.env.get('COMPILE_PATH') || 'bin'
const UNCOMPILED_RULES_PATH = join('.cursor', 'rules', 'global')
const OUTPUT_PATH = join(COMPILE_PATH, 'rules.json')
const MARKDOWN_PATH = join(COMPILE_PATH, 'rules.md')
const HTML_PATH = join(COMPILE_PATH, 'rules.html')
const HOW_RULES_WORK_SRC = join('docs', 'how-cursor-rules-work.md')
const HOW_RULES_WORK_DEST = join(COMPILE_PATH, 'how-cursor-rules-work.md')
const GITHUB_MARKDOWN_API = 'https://api.github.com/markdown/raw'

/**
 * Renders a collection of items with collapsible section if needed
 *
 * @param items - Array of items to render
 * @param maxVisible - Maximum number of items to show before collapsing
 * @param useCodeTags - Whether to wrap items in HTML code tags
 * @returns HTML string with visible and potentially collapsed items
 */
function renderCollapsibleList(items: string[], maxVisible: number, useCodeTags = true): string {
  if (items.length === 0) return ''

  const sortedItems = [...items].sort()

  // Format each item with HTML code tags if requested
  const formatItem = (item: string) => useCodeTags ? `<code>${item}</code>` : item
  const visibleItems = sortedItems.slice(0, maxVisible).map(formatItem).join(', ')

  // If we have more items than maxVisible, create a collapsible section
  if (sortedItems.length > maxVisible) {
    const hiddenItems = sortedItems.slice(maxVisible).map(
      (item) => `<code>${item}</code>`,
    ).join(', ')
    const remainingCount = sortedItems.length - maxVisible

    return `${visibleItems}
<details>
  <summary><em>Show ${remainingCount} more</em></summary>
  ${hiddenItems}
</details>`
  }

  return visibleItems
}

// Markdown styling configuration
const MARKDOWN_CONFIG = {
  header: `<!-- This document was auto-generated by Cursor Workbench on ${
    new Date().toISOString().replace('T', ' ').substring(0, 19)
  } and uses [Github Flavored Markdown](https://github.github.com/gfm/#atx-headings) -->

# Available Cursor Rules In This Project

This project contains Cursor rules created through **Cursor Workbench**!

This document was auto-generated and describes all global rules used by this project in the \`.cursor/rules/global\` directory.

> [!TIP]
> **New to Cursor Rules?** Read this deep-dive guide on [How Cursor Rules Work](./how-cursor-rules-work.md).

> [!NOTE]
> Rules in \`.cursor/rules/global\` are used for global rules shared with the project and others. Project-specific rules unique to this project should be stored in \`.cursor/rules/local\` or \`.cursor/rules/\` instead.

`,
  customRuleFieldsDescription:
    'This project adds specialized fields to the frontmatter on Cursor rule files that help with discoverability of rules as well as extending their functionality outside of what Cursor provides. This section documents all of the custom fields used in Cursor rules for this project.\n\n' +
    '> [!IMPORTANT]\n' +
    "> The Cursor IDE opens rule files by default using the Cursor MDC Editor, which hides all of the frontmatter fields that are contained in the raw file. If you'd like to see or edit any of the custom fields you'll need to open the .mdc file in a plain text editor.\n\n" +
    '> [!TIP]\n' +
    '> It\'s recommended to choose a default editor for .mdc files by setting `"workbench.editorAssociations": {"*.mdc": "default"}` in your settings.json. This will make editing custom fields contained in the frontmatter header easier. You can still choose \'Open With -> MDC Editor\' to use Cursor\'s editor at any time by right-clicking the rule file.',
  ruleClassifierSections: [
    {
      title: 'Field:Attachment Type',
      description:
        'The attachment type defines how a rule is loaded and activated in Cursor. Its value is sat during compilation and derived from the the standard Cursor rule file fields of: the `alwaysApply`, `globs`, and `description` fields. Example: `alwaysApply: true` makes a rule always active.',
      renderBody: (): string => {
        let body = ''
        for (
          const [type, description] of Object.entries(MARKDOWN_CONFIG.attachmentTypeDescriptions)
        ) {
          // Add an HTML anchor for each attachment type
          body +=
            `- <a id="attachment-type-${type.toLowerCase()}"></a>**${type}**: ${description}\n`
        }
        return body
      },
    },
    {
      title: 'Field: Attachment Method',
      description:
        'The attachment method controls how a rule is injected into the context when activated. Set in the frontmatter using the `attachmentMethod` field. Example: `attachmentMethod: system` makes a rule override the system prompt.',
      renderBody: (): string => {
        let body = ''
        for (
          const [method, description] of Object.entries(
            MARKDOWN_CONFIG.attachmentMethodDescriptions,
          )
        ) {
          if (method === 'default') continue // Skip the default entry
          const formattedMethod = method.charAt(0).toUpperCase() + method.slice(1)
          body +=
            `- <a id="attachment-method-${method.toLowerCase()}"></a>**${formattedMethod}**: ${description}\n`
        }
        return body
      },
    },
    {
      title: 'Field:Category',
      description:
        "Adding a `category` in a rule's frontmatter helps organize and discover rules in your codebase. Examples of useful categories: `Code Generation`, `Tool Usage`, `Testing and Debugging`, `Documentation`, `Code Style`, etc. The `category` field makes it easier to filter and group rules when you have a large collection.",
      renderBody: (rules: RuleFileSimple[]): string => {
        // Collect unique categories
        const categories = new Set<string>()
        for (const rule of rules) {
          if (rule.category) {
            categories.add(rule.category.toLowerCase())
          }
        }

        if (categories.size === 0) {
          return 'No categories are currently used in this project.\n'
        }

        return `**Categories Used In This Project:** ${
          renderCollapsibleList(Array.from(categories), MARKDOWN_CONFIG.maxItemsBig)
        }\n`
      },
    },
    {
      title: 'Field: Tags',
      description:
        "Adding a tag to the `tags` field in a rule's frontmatter provides another way to categorize and filter rules. Tags are specified as a comma-separated string in the frontmatter. Each tag can contain spaces and multiple words.",
      renderBody: (rules: RuleFileSimple[]): string => {
        // Collect unique tags
        const tags = new Set<string>()
        for (const rule of rules) {
          if (rule.tags && Array.isArray(rule.tags)) {
            for (const tag of rule.tags) {
              tags.add(tag.toLowerCase())
            }
          }
        }

        if (tags.size === 0) {
          return 'No tags are currently used in this project.\n'
        }

        return `**Tags Used In This Project:** ${
          renderCollapsibleList(Array.from(tags), MARKDOWN_CONFIG.maxItemsBig)
        }\n`
      },
    },
  ],
  table: {
    columnWidths: {
      rule: 15, // Width % for rule name column
      description: 40, // Width % for description column (increased to accommodate attachment type)
      tags: 35, // Width % for tags column
    },
    columnAlignment: {
      rule: 'left',
      description: 'left',
      tags: 'left',
    },
  },
  maxItemsSmall: 5, // Maximum tags to show in tables before using expandable section
  maxItemsBig: 25, // Maximum tags to show in Tags/Category section before using expandable section
  attachmentMethodDescriptions: {
    system:
      'System attachment method. Injects into the internal system prompt and attempts to overrule it. Best for setting modes, establishing base AI instructions, and rules that need to set agent context before a conversation or task begins.',
    message:
      'Message attachment method (default). Injects into the current user message or conversation. Best for most rule types and general-purpose rules that augment the current interaction context.',
    task:
      'Task attachment method. Injects into the current message or conversation and explicitly instructs the agent to perform an action. Best for rules that should initiate specific agent behaviors, such as creating a file if the rule is named "@create-file".',
    none:
      'No attachment method/reference only. References the rule without loading its full content into the current context. Best for large or complex rules that you only want lazy-loaded by the agent at certain steps in your instructions. The agent will be aware of the rule and will have the choice to load its contents when it chooses.',
    default: 'Custom attachment method with behavior defined by the system.',
  },
  attachmentTypeDescriptions: {
    AlwaysAttached:
      'Defined by `alwaysApply: true` in frontmatter. The rule is always active in the Cursor context.',
    AutoAttached:
      'Defined by `alwaysApply: false` with non-empty `globs` in frontmatter. The rule is automatically activated when a file matching the `globs` pattern is opened or focused in Cursor.',
    AgentAttached:
      'Defined by non-empty `description` in frontmatter. Loaded and used by the AI agent based on context, guided by the `description`.',
    ManuallyAttached:
      'Defined by `alwaysApply: false`, empty or no `globs`, empty or no `description`. The rule is only activated when manually referenced by the user with `@rule-name`.',
  },
} as const

/**
 * Run the MDC linter to ensure all files are valid
 *
 * @param path - Directory path with MDC files to lint
 * @returns True if linting passed with no errors (warnings are allowed)
 */
async function runLinter(path: string): Promise<boolean> {
  logger.log(`Running linter on MDC files in: ${path}`)

  const command = new Deno.Command('deno', {
    args: [
      'run',
      '-A',
      join('src', 'linter.ts'),
      join(path, '**/*.mdc'),
    ],
    stdout: 'piped',
    stderr: 'piped',
  })

  const { stderr, code } = await command.output()
  const decoder = new TextDecoder()
  const stderrText = decoder.decode(stderr)

  if (stderrText.trim()) {
    logger.error('Linter error:')
    logger.error(stderrText)
  }

  // NOTE: Warnings are allowed, so we don't exit on failure
  return code === 0
}

/**
 * Get file creation and last update dates from git history
 *
 * @param filePath - Path to the file
 * @returns Object containing createdOn and updatedOn dates
 */
async function getGitDates(
  filePath: string,
): Promise<{ createdOn: string | null; updatedOn: string | null }> {
  try {
    // Get creation date (first commit with this file)
    const creationCommand = new Deno.Command('git', {
      args: ['log', '--follow', '--format=%aI', '--reverse', filePath],
      stdout: 'piped',
      stderr: 'piped',
    })

    const creationOutput = await creationCommand.output()
    let createdOn: string | null = null

    if (creationOutput.code === 0) {
      const decoder = new TextDecoder()
      const output = decoder.decode(creationOutput.stdout).trim()
      const dates = output.split('\n').filter(Boolean)

      if (dates.length > 0) createdOn = dates[0]
    }

    // Get last update date (most recent commit with this file)
    const updateCommand = new Deno.Command('git', {
      args: ['log', '--format=%aI', '-n', '1', filePath],
      stdout: 'piped',
      stderr: 'piped',
    })

    const updateOutput = await updateCommand.output()
    let updatedOn: string | null = null

    if (updateOutput.code === 0) {
      const decoder = new TextDecoder()
      const output = decoder.decode(updateOutput.stdout).trim()

      if (output) {
        updatedOn = output
      }
    }

    return { createdOn, updatedOn }
  } catch (error) {
    logger.error(`Error getting git dates for ${filePath}:`, error)
    return { createdOn: null, updatedOn: null }
  }
}

/**
 * Processes all .mdc files in a directory and its subdirectories
 *
 * @param path - Directory path to search for .mdc files
 * @returns Array of processed RuleFileRaw objects
 */
async function processMdcFiles(path: string): Promise<RuleFileRaw[]> {
  const mdcFiles: RuleFileRaw[] = []
  const globPattern = join(path, '**/*.mdc')

  // Use expandGlob to recursively find all .mdc files
  for await (const entry of expandGlob(globPattern)) {
    if (entry.isFile) {
      logger.log(`Processing file: ${entry.path}`)
      const processedFile = await processMdcFile(entry.path)
      mdcFiles.push(processedFile)
    }
  }

  return mdcFiles
}

/**
 * Creates a markdown file from the rules data, organizing rules by category
 *
 * @param rules - Array of processed rule objects
 * @returns Markdown content as a string
 */
function createRulesMarkdown(rules: RuleFileSimple[]): string {
  // Start with the header from config
  let markdown = MARKDOWN_CONFIG.header

  // Add Custom Cursor Rule Fields section
  markdown += '\n## Custom Cursor Rule Fields\n\n'

  // Add the description text for the Custom Cursor Rule Fields section
  markdown += `${MARKDOWN_CONFIG.customRuleFieldsDescription}\n\n`

  // Process each rule classifier section from the configuration
  for (const section of MARKDOWN_CONFIG.ruleClassifierSections) {
    markdown += `### ${section.title}\n\n`

    // Add section description if provided
    if (section.description) {
      markdown += `${section.description}\n\n`
    }

    // Render the body content using the section's renderBody function
    markdown += section.renderBody(rules)
    markdown += '\n'
  }

  // Add single H2 section for all rules
  markdown += '\n## All Rules By Category\n\n'

  // Group rules by category
  const rulesByCategory: Record<string, RuleFileSimple[]> = {}

  for (const rule of rules) {
    const category = rule.category || 'Uncategorized'

    if (!rulesByCategory[category]) {
      rulesByCategory[category] = []
    }

    rulesByCategory[category].push(rule)
  }

  // Sort categories
  const sortedCategories = Object.keys(rulesByCategory).sort()

  // Create subsections for each category
  for (const category of sortedCategories) {
    const rulesInCategory = rulesByCategory[category]

    // Format category name for display (capitalize first letter of each word)
    const formattedCategory = category
      .split(' ')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ')

    markdown += `\n### ${formattedCategory}\n\n`

    // Add a table for rules in this category using HTML for fixed column widths
    const { rule, description, tags } = MARKDOWN_CONFIG.table.columnWidths

    // Use HTML table with explicit column widths instead of GFM table
    markdown += `<table width="100%">
  <tr>
    <th width="${rule}%" align="left">Rule</th>
    <th width="${description}%" align="left">Description</th>
    <th width="${tags}%" align="left">Tags</th>
  </tr>
`

    for (const rule of rulesInCategory) {
      const ruleName = rule.rule
      const ruleDescription = rule.description || 'No description provided'
      const attachmentMethod = rule.attachmentMethod || 'none'
      const formattedMethod = attachmentMethod.charAt(0).toUpperCase() + attachmentMethod.slice(1)

      // Use the actual attachment type value directly
      const attachmentTypeName = rule.attachmentType || AttachmentType.Unknown

      // Add globs information if available
      let globsInfo = ''
      if (rule.globs) {
        if (Array.isArray(rule.globs)) {
          globsInfo = ` Applies to \`${rule.globs.join('`, `')}\` files.`
        } else {
          globsInfo = ` Applies to \`${rule.globs}\` files.`
        }
      }

      // Format tags if available
      let tagsText = '-'
      if (rule.tags && Array.isArray(rule.tags) && rule.tags.length > 0) {
        // Convert tags to HTML code elements instead of using backticks
        const formatTag = (tag: string) => `<code>${tag}</code>`
        const visibleTags = rule.tags.slice(0, MARKDOWN_CONFIG.maxItemsSmall).map(formatTag).join(
          ', ',
        )

        // If we have more tags than maxItemsSmall, create a collapsible section
        if (rule.tags.length > MARKDOWN_CONFIG.maxItemsSmall) {
          const hiddenTags = rule.tags.slice(MARKDOWN_CONFIG.maxItemsSmall).map(formatTag).join(
            ', ',
          )
          const remainingCount = rule.tags.length - MARKDOWN_CONFIG.maxItemsSmall

          tagsText = `${visibleTags}<br>
<details>
  <summary><em>Show ${remainingCount} more</em></summary>
  ${hiddenTags}
</details>`
        } else {
          tagsText = visibleTags
        }
      }

      // Create HTML table row with attachment type and method display
      markdown += `  <tr>
    <td><strong><code>@${ruleName}</code></strong></td>
    <td><strong>Type</strong>: <a href="#attachment-type-${
        (attachmentTypeName || '').toLowerCase()
      }">${attachmentTypeName}</a><br><strong>Method</strong>: <a href="#attachment-method-${attachmentMethod.toLowerCase()}">${formattedMethod}</a><br><br>${ruleDescription}${globsInfo}</td>
    <td align="left">${tagsText}</td>
  </tr>
`
    }

    // Close HTML table
    markdown += '</table>\n\n'
  }

  return markdown
}

/**
 * Converts markdown content to HTML using GitHub's Markdown API
 *
 * @param markdownContent - The markdown content to convert
 * @returns HTML content as a string
 */
async function convertMarkdownToHtml(markdownContent: string): Promise<string> {
  try {
    logger.log('Converting markdown to HTML using GitHub API...')

    const response = await fetch(GITHUB_MARKDOWN_API, {
      method: 'POST',
      headers: {
        'Content-Type': 'text/x-markdown',
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Cursor-Config-Builder',
      },
      body: markdownContent,
    })

    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(`GitHub API error (${response.status}): ${errorText}`)
    }

    const html = await response.text()

    // Add basic HTML wrapper with styling for better readability
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cursor Rules Documentation</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      max-width: 980px;
      margin: 0 auto;
      padding: 45px;
      line-height: 1.5;
    }
    pre, code {
      font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
      background-color: rgba(27, 31, 35, 0.05);
      border-radius: 3px;
      padding: 0.2em 0.4em;
    }
    pre {
      padding: 16px;
      overflow: auto;
    }
    pre code {
      background-color: transparent;
      padding: 0;
    }
    table {
      border-collapse: collapse;
      width: 100%;
    }
    table th, table td {
      padding: 6px 13px;
      border: 1px solid #dfe2e5;
    }
    table tr {
      background-color: #fff;
      border-top: 1px solid #c6cbd1;
    }
    table tr:nth-child(2n) {
      background-color: #f6f8fa;
    }
  </style>
</head>
<body>
  ${html}
</body>
</html>`
  } catch (error) {
    logger.error(
      `Error converting markdown to HTML: ${
        error instanceof Error ? error.message : String(error)
      }`,
    )
    throw error
  }
}

/**
 * Main function that:
 * 1. Runs the linter to validate MDC files
 * 2. If linting passes, processes all .mdc files in the specified directory
 * 3. Simplifies the data format
 * 4. Writes the parsed metadata to a JSON file
 * 5. Creates a markdown file from the rules data
 * 6. Converts markdown to HTML and saves as rules.html
 */
async function main() {
  try {
    // Get directory path from command line args or use default
    const path = Deno.args[0] || UNCOMPILED_RULES_PATH
    logger.log(`Scanning for .mdc files in: ${path}`)

    // Run the linter first to validate the MDC files
    const lintingPassed = await runLinter(path)

    // Only continue if linting passed (no errors)
    if (!lintingPassed) {
      logger.error('Linting failed with errors. Fix the errors before building rules.json.')
      Deno.exit(1)
    }

    logger.log('Linting passed (warnings are allowed). Continuing with build...')

    // Process all .mdc files
    const processedFiles = await processMdcFiles(path)
    logger.log(`Processed ${processedFiles.length} .mdc files`)

    // Simplify the rules - inlined from simplifyRules()
    const processedRules = await Promise.all(processedFiles.map(async (file) => {
      // Extract rule name from file path (remove .mdc extension) - inlined from extractRuleName()
      const rule = basename(file.filePath, extname(file.filePath))

      // Get git creation and update dates
      const { createdOn, updatedOn } = await getGitDates(file.filePath)

      const ruleMetadata: RuleFileSimple = {
        rule,
        attachmentType: file.derivedAttachmentType || AttachmentType.Unknown,
        createdOn,
        updatedOn,
        category: file.frontmatter?.category || null,
        description: file.frontmatter?.description || null,
        globs: file.frontmatter?.globs || null,
        tags: file.frontmatter?.tags || null,
        alwaysApply: file.frontmatter?.alwaysApply || null,
        attachmentMethod: file.frontmatter?.attachmentMethod || null,
      }

      // Add any remaining properties from frontmatter
      if (file.frontmatter) {
        for (const [key, value] of Object.entries(file.frontmatter)) {
          // Skip properties we've already added and internal properties
          if (
            key === 'description' || key === 'globs' || key === 'alwaysApply' || key === 'tags' ||
            key === 'raw' || key === 'parseError' || key === 'startLine' || key === 'endLine'
          ) {
            continue
          }
          ruleMetadata[key] = value
        }
      }

      return ruleMetadata
    }))

    try {
      await ensureDir(dirname(OUTPUT_PATH))

      await Deno.writeTextFile(
        OUTPUT_PATH,
        JSON.stringify(processedRules, null, 2),
      )

      logger.log(`Successfully wrote metadata to ${OUTPUT_PATH}`)

      // Create markdown file from the rules data
      const markdownContent = createRulesMarkdown(processedRules)

      await Deno.writeTextFile(
        MARKDOWN_PATH,
        markdownContent,
      )

      logger.log(`Successfully wrote markdown to ${MARKDOWN_PATH}`)

      // Convert markdown to HTML using GitHub API
      try {
        const htmlContent = await convertMarkdownToHtml(markdownContent)
        await Deno.writeTextFile(HTML_PATH, htmlContent)
        logger.log(`Successfully converted markdown to HTML and saved to ${HTML_PATH}`)
      } catch (error) {
        logger.error(
          `Warning: Could not convert markdown to HTML: ${
            error instanceof Error ? error.message : String(error)
          }`,
        )
        // Continue execution even if this step fails
      }

      // Copy the how-cursor-rules-work.md file to the bin folder
      try {
        await Deno.copyFile(HOW_RULES_WORK_SRC, HOW_RULES_WORK_DEST)
        logger.log(`Successfully copied ${HOW_RULES_WORK_SRC} to ${HOW_RULES_WORK_DEST}`)
      } catch (error) {
        logger.error(
          `Warning: Could not copy documentation file: ${
            error instanceof Error ? error.message : String(error)
          }`,
        )
        // Continue execution even if this step fails
      }
    } catch (error) {
      throw new Error(
        `Failed to write output files: ${error instanceof Error ? error.message : String(error)}`,
      )
    }
  } catch (error) {
    if (error instanceof URIError) {
      logger.error('URI Error:', error.message)
    } else if (error instanceof SyntaxError) {
      logger.error('Syntax Error:', error.message)
    } else if (error instanceof Error) {
      logger.error('Error:', error.message)
    } else {
      logger.error('Unknown error:', String(error))
    }
    Deno.exit(1)
  }
}

// Run the main function
main()
