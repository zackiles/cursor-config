---
description: Generating code in Javascript and Typescript files
globs: *.ts, *.js
---
## CODING STYLE GUIDE (MANDATORY OR STRONGLY ENCOURAGED)

### Naming
- **snake_case** for file names.  
- **camelCase** for instance names.  
- **PascalCase** for class and symbol names.  
- **UPPER_SNAKE_CASE** for constants.

### Code Ordering
- **Remote Imports**  
- **Local Imports**  
- **Hoisted Variables and References**  
- **Methods**  
- **Exports**

### Syntax
- Favor modern ECMAScript features and patterns:  
  - Object & array **destructuring**  
  - **Optional chaining** (`?.`) & **nullish coalescing** (`??`)  
  - **Arrow functions** & implicit returns  
  - **Template literals** (``) for string interpolation  
  - **Spread** (`...`) & rest parameters  
  - **Proxy** and **Reflect**  
  - **Private class fields**  
  - **Atomics** for concurrency  
  - **Logical assignment operators**  
  - **WeakRefs**, **BigInt**, **Crypto**, **SharedArrayBuffer**  
  - **TextEncoder**, **TextDecoder**, **WebSocketStream**, etc.

### Functional & Compositional Approach
- Within functions, prefer **functional** over imperative control flows.  
- Avoid deeply nested callbacks or chains.  
- When designing classes or relationships, use **composition** over generalization/inheritance.

**Examples:**

**BAD (Imperative):**
```javascript
// Overly imperative
this.on('some action', async (event) => {
  try {
    await handle(event).then(async (ev) => {
      return await endAction(ev)
    })
    .catch((err) => {
      console.error(err)
    })
  } catch(err) {
    console.error(err)
  }
})
```

**GOOD (Functional):**
```javascript
// Reduces code length, boosts readability
const errorHandler = console.error
const eventHandler = event => handle(event).then(endAction).catch(errorHandler)
this.on('some action', eventHandler)
```

### Documentation in Code
- Use **JSDoc** for functions and files (including `@module` docs with examples).  
- **DANGER**: When updating code, never remove JSDoc or linting comments unless explicitly requested. If changes break comments, update them accurately.

### Functional vs. OOP
- If entities have large state or define strict interfaces, consider using classes.  
- Otherwise, default to simple, pure functions and straightforward code.

### Pragmatic Proofs of Concept (PoCs)
- For new codebases or prototypes:  
  - Use a **flat file/folder structure**  
  - Write minimal or no tests (maybe one smoke test)  
  - Choose **unopinionated, flexible designs**  
  - Prefer **modern open-source libraries**  
  - If fewer than 5 main JS/TS files exist, keep everything as minimal as possible.

### TypeScript Types
- Avoid or reduce internal usage of types for classes, methods, variables, or interfaces.  
- Expose types only at application boundaries or in public APIs (e.g., library exports).

### Private / Public Interfaces
- Mark private fields or functions clearly.  
- For public interfaces, ensure a clean, well-documented user experience.  
- Patterns may include private fields, singletons, factories, prototypes, observers, or dependency injection.

### Imports
- Understand what is being imported to leverage the latest ESM features (e.g., `import type`, import maps, import attributes).
