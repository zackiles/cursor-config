---
description: Generating code in Javascript and Typescript files
globs: *.ts, *.js
alwaysApply: false
---
## CODING STYLE GUIDE - JAVASCRIPT AND TYPESCRIPT (MANDATORY OR STRONGLY ENCOURAGED)

### Naming
- **snake_case** for file names.  
- **camelCase** for instance names.  
- **PascalCase** for class and symbol names.  
- **UPPER_SNAKE_CASE** for constants.

### Code Ordering
- **Remote Imports**  
- **Local Imports**  
- **Hoisted Variables and References**  
- **Methods**  
- **Exports**

### Syntax
- Favor modern ECMAScript features and patterns:  
  - Object & array **destructuring**  
  - **Optional chaining** (`?.`) & **nullish coalescing** (`??`)  
  - **Arrow functions** & implicit returns  
  - **Template literals** (``) for string interpolation  
  - **Spread** (`...`) & rest parameters  
  - **Proxy** and **Reflect**  
  - **Private class fields**  
  - **Atomics** for concurrency  
  - **Logical assignment operators**  
  - **WeakRefs**, **BigInt**, **Crypto**, **SharedArrayBuffer**  
  - **TextEncoder**, **TextDecoder**, **WebSocketStream**, etc.
- **Semicolon Usage**
  - **Always** follow the existing codebase's semicolon style
  - If the codebase uses semicolons, include them consistently
  - If the codebase omits semicolons, ensure they are not added
  - When in doubt, verify the style in multiple files before making assumptions
  - For new codebases, default to **no semicolons** unless specified otherwise
- **Nesting and Chaining**
  - Avoid deeply nested code within functions.
  - Refactor deeply nested code by grouping and hoisting related functionationliy at the top of the function, and then call it with functional patterns or chaining toward the bottom.
  - For code that contains multiple steps define those steps early and clearly in the function in a way that enhances the maintainability and readability.
  - Where possible (and where it doesn't harm readability) instead of defining multiple variables, collapse that variables into a only a single one or a few where it's value is the result of several chained methods.

### Functional & Compositional Approach
- Within functions, prefer **functional** over imperative control flows.  
- Avoid deeply nested callbacks or chains.  
- When designing classes or relationships, use **composition** over generalization/inheritance.

**Examples:**

**BAD (Imperative):**
```javascript
// Overly imperative
this.on('some action', async (event) => {
  try {
    await handle(event).then(async (ev) => {
      return await endAction(ev)
    })
    .catch((err) => {
      console.error(err)
    })
  } catch(err) {
    console.error(err)
  }
})
```

**GOOD (Functional):**
```javascript
// Reduces code length, boosts readability
const errorHandler = console.error
const eventHandler = event => handle(event).then(endAction).catch(errorHandler)
this.on('some action', eventHandler)
```

### Documentation in Code
- Use **JSDoc** for functions and files (including `@module` docs with examples).
- Never include inline comments to describe code that can easily be understood.
- Never include inline comments that are redundant, innacurate, or used only to help group sections of code unless the user asks you to.
- **DANGER**: When updating code, never remove JSDoc or linting comments unless explicitly requested. If changes break comments, update them accurately.

### Functional vs. OOP
- If entities have large state or define strict interfaces, consider using classes.  
- Otherwise, default to simple, pure functions and straightforward code.

### Pragmatic Proofs of Concept (PoCs)
- For new codebases or prototypes:  
  - Use a **flat file/folder structure**  
  - Write minimal or no tests (maybe one smoke test)  
  - Choose **unopinionated, flexible designs**  
  - Prefer **modern open-source libraries**  
  - If fewer than 5 main JS/TS files exist, keep everything as minimal as possible.

### TypeScript Types
- Avoid or reduce internal usage of types for classes, methods, variables, or interfaces.  
- Expose types only at application boundaries or in public APIs (e.g., library exports).

### Private / Public Interfaces
- Mark private fields or functions clearly.  
- For public interfaces, ensure a clean, well-documented user experience.  
- Patterns may include private fields, singletons, factories, prototypes, observers, or dependency injection.

### Imports
- Understand what is being imported to leverage the latest ESM features (e.g., `import type`, import maps, import attributes).
- Imports should be cordered according to the rules about imports in "### Code Ordering".

### Exports
- Exports should always be declared at the bottom of code files and never in the middle.
- Exports delcarations should be as free of logic as possible.
- Prefer simple object exports such as `export {someMethod, anotherMethod}`.

### Error Handling Strategy
- Discourage deeply nested try/catch blocks; prefer flat promise chains and modular error handling.
- Handle asynchronous errors using Promise.allSettled for concurrent operations and catch() chaining for individual error capture.

### Immutable Data Patterns
- Avoid direct mutation of objects and arrays; use immutable operations like map, reduce, and Object.freeze() to maintain state integrity.
- When deep copying, consider using `structuredClone` to avoid unintended mutations.

### Concurrency & Performance Optimizations
- Prefer queueMicrotask() for scheduling microtasks to enhance responsiveness.
- Use Atomics and SharedArrayBuffer for managing shared memory and concurrent operations.
- Utilize Web Workers for parallel processing, offloading heavy computations from the main thread.

### Module Organization
- Follow ESM-only practices; avoid CommonJS imports to maintain modern module consistency.
- Prevent circular dependencies by designing clear module boundaries and keeping responsibilities separate.

### Memory & Performance Considerations
- Optimize large dataset handling by leveraging streaming APIs to process data incrementally.
- Minimize memory footprint using lazy evaluation techniques, processing data only as needed.

### Minimal Testing Strategy
- Recommend integration tests over unit tests for backend logic to ensure system-wide reliability.
- Use built-in test runners from Deno, Bun, or Node based on the runtime environment.
- Favor testable function design with pure functions and minimal side effects to simplify testing.

### Security Best Practices
- Prefer using the built-in crypto.subtle API for cryptographic operations, reducing dependency on third-party libraries.

### Logging & Debugging Strategy
- Employ structured logging (e.g., JSON-based logs) to facilitate clear and consistent log management.
- Enable stack traces for detailed error reporting during development.
- Limit logging in production to critical events to avoid performance degradation.


## Writing and Writing Code For Readability, Cleanliness, and Maintainability
- Review all lines of code you've edited or will be editing or generating to ensure all the rules mentioned to you below are applied.
- When rewriting previous code, also apply these rules while ensuring the overall coding standards of this codebase are maintained if these rules conflict with the current standard.

### Rules for Clean Code

- Always try to reduce the amount of code or lines of code needed to do the same thing
- If multiple variables are required and shared in a method or module, consider grouping them into logcal objects and hoisting them so they can be accessed, instead of declaring multiple variables over several lines of code. This will ensure less code is needed to do the same thing.
- Avoid repeated or deeply nested try/catch or if/else blocks inside module or class methods. Instead find ways to compose the code in more a more functional manner such as chaining or hoisting nested arrow functions within methods so that it improves readability, reduces the amount of code needed to do accomplish what we need, and reduces deep nesting inside module or class methods.
- When refactoring, find alternative solutions, patterns, methods and code that can be used instead of the current code that would reduce the total amount of code or lines of code if it was used instead. Always look to redopportunities to 
- Only define large multi-line strings at the top of files instead of inside methods.
- Define important static variables and configuration at the highest points reasonable to their scope, such as the top of the method or the top of a class or file (but after imported or module jsdoc descriptions).

### Rules for Maintainable Code
- **Keep similar code together**: Function callers and callees should be kept close.
- **Scrutinize inline comments**: Keep only the most well-written and useful inline comments. Review previews comments for accuracy and usefullness. Only comment things that have business logic complexity. Comments are an apology for difficult to understand code, not a requirement. Good code mostly documents itself.
- Export only the methods of a module that will be used by other modules unless you've been asked to export them or another file relies on them.
- Methods of a class are private by default unless it's obvious they'd need to be used by consumers.
- If your class/object name tells you something, don't repeat that in your variable name. Don't add uneeded context. For example, if a class is named `Car`, don't add a variable to it named `Car.carHorn`, instead use just `Car.horn`.
- Use default parameters instead of short circuiting or conditionals.
- **Function arguments**: use two or fewer ideally. If many arguments are required consider using one or two arguments that contain multiple arguments inside them. Examples: GOOD `function create({data: 'hello'}, options = {})`, BAD `function create (data, name, time, options)`
- Remove duplicate or reptitive code by consolidating.
- Remove dead code. If something is not being used remove it or comment it out if you think removing it might break something or frustrate the user.
- **Open/Closed Principle (OCP)**: software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification
- **Liskov Substitution Principle (LSP)**: If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).
- **Interface Segregation Principle (ISP)**: Clients should not be forced to depend upon interfaces that they do not use. Interfaces are implicit contracts in JavaScript because of duck typing. An example if ISP: not requiring clients to setup huge amounts of options is beneficial, because most of the time they won't need all of the settings. Making them optional helps prevent having a "fat interface".

### Rules for Readable Code
Simple, compact, and elegant code is easier for the reader to read as it doesn't force them to scroll or read many lines of the code to understand what's going on. Some examples:

- Use arrow functions for concise callbacks and implicit returns:  
  ```
  const add = (a, b) => a + b
  ```  
- Apply default and destructured parameters to reduce boilerplate:  
  ```
  function greet({ name = 'Guest' } = {}) {
    return `Hello, ${name}`
  }
  ```  
- Employ higher-order functions for composability:  
  ```
  const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x)
  ```  
- Embrace point-free style to reduce explicit parameters:  
  ```
  const double = x => x * 2
  const increment = x => x + 1
  const process = compose(increment, double)
  ```  
- Use partial application or currying for reusability:  
  ```
  const partialAdd = a => b => a + b
  const addFive = partialAdd(5)
  addFive(10)
  ```  
- Prefer immutable operations (map, filter, reduce) over loops:  
  ```
  const squares = [1,2,3].map(x => x*x)
  ```  
- Leverage optional chaining for safe property access:  
  ```
  const streetName = person?.address?.street
  ```  
- In TypeScript, exploit type inference and generics to minimize annotations:  
  ```
  function identity<T>(value: T): T {
    return value
  }
  ```  
- Combine utility types (Partial, Pick, Omit) to reduce type verbosity:  
  ```
  type PartialUser = Partial<User>
  ```  
- Export small, focused modules rather than monolithic ones to keep code modular and concise  

